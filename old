import asyncio
import websockets
import sounddevice as sd
import numpy as np
import json
import queue
import threading
import time
import base64

# ===== Config =====
SERVER_IP = "172.21.11.61"
SERVER_PORT = 8080
REQUEST = {
    "text": "यूसीआई एक तात्कालिक भुगतान प्रणाली है जिसे नेशनल पेमेंट्स कॉर्पोरेशन ऑफ इंडिया द्वारा विकसित किया गया है, जो एक आरबीआई पहल है।",
    "chunk_size": 4  # Smaller chunks for lower latency
}

audio_queue = queue.Queue(maxsize=10)
stop_flag = False
samplerate = None  # Will be 8000 Hz (WebSocket processed)

def playback_worker():
    global stop_flag
    try:
        while not stop_flag or not audio_queue.empty():
            try:
                audio_data = audio_queue.get(timeout=0.1)
                sd.play(audio_data, samplerate=samplerate, blocking=True)
            except queue.Empty:
                continue
            except Exception as e:
                print(f" Playback error: {e}")
                break
    except Exception as e:
        print(f" Playback worker error: {e}")

async def websocket_receiver(websocket):
    global samplerate, stop_flag
    
    try:
        # ===== Send request to server =====
        print(f"Request: {json.dumps(REQUEST, ensure_ascii=False)}")
        await websocket.send(json.dumps(REQUEST))
        print("Request sent to WebSocket server")

        chunk_idx = 0
        first_chunk = True
        start_time = time.time()
        total_audio_duration = 0
        
        # Listen for messages from server
        async for message in websocket:
            try:
                data = json.loads(message)

                # ===== Print response in simple format =====
                data_for_print = data.copy()
                if data_for_print.get("type") == "audio_chunk":
                    data_for_print["audio_data"] = "<audio buffer>"
                print(f"Response: {json.dumps(data_for_print, ensure_ascii=False)}")
                
                if data["type"] == "config":
                    samplerate = data["sample_rate"]
                    print(f" Server samplerate: {samplerate} Hz (WebSocket processed)")
                    print(f" Server message: {data['message']}")
                
                elif data["type"] == "audio_chunk":
                    # Decode base64 audio data
                    audio_bytes = base64.b64decode(data["audio_data"])
                    pcm_array = np.frombuffer(audio_bytes, dtype=np.int16).astype(np.float32) / 32767.0
                    
                    audio_duration = len(pcm_array) / samplerate
                    total_audio_duration += audio_duration
                    
                    # Add to playback queue
                    try:
                        audio_queue.put(pcm_array, timeout=5.0)
                    except queue.Full:
                        print(" Audio queue full, dropping chunk")
                        continue

                    chunk_idx += 1
                    if first_chunk:
                        first_chunk = False
                        latency = time.time() - start_time
                        print(f" Time to first audio: {latency:.2f}s")
                    
                    print(f" Chunk {data['chunk_id']}/{data['total_chunks']}: {data['bytes_count']} bytes, {audio_duration:.2f}s audio")

                elif data["type"] == "stream_end":
                    print(" End of stream signal received")
                    print(f" Server message: {data['message']}")
                    print(f" Total chunks received: {data['total_chunks']}")
                    break
                
                elif data["type"] == "error":
                    print(f" Server error: {data['message']}")
                    break
                
                else:
                    print(f" Unknown message type: {data['type']}")

            except json.JSONDecodeError as e:
                print(f" JSON decode error: {e}")
                break
            except Exception as e:
                print(f" Message processing error: {e}")
                continue

        print(f" Total audio duration: {total_audio_duration:.2f}s")

    except websockets.exceptions.ConnectionClosed:
        print(" WebSocket connection closed")
    except Exception as e:
        print(f" WebSocket receiver error: {e}")
    finally:
        stop_flag = True

def run_websocket_client():
    """Run the WebSocket client in a separate thread"""
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    
    async def client_main():
        uri = f"ws://{SERVER_IP}:{SERVER_PORT}"
        try:
            async with websockets.connect(
                uri,
                ping_interval=20,
                ping_timeout=10,
                close_timeout=10,
                proxy=None
            ) as websocket:
                print(f" Connected to WebSocket server: {uri}")
                await websocket_receiver(websocket)
        except Exception as e:
            print(f" WebSocket connection error: {e}")
    
    try:
        loop.run_until_complete(client_main())
    finally:
        loop.close()

def main():
    global samplerate, stop_flag
    
    print(f" Connecting to WebSocket server: ws://{SERVER_IP}:{SERVER_PORT}")
    
    try:
        # Start WebSocket client in a separate thread
        websocket_thread = threading.Thread(target=run_websocket_client, daemon=True)
        websocket_thread.start()

        # Wait for samplerate to be received
        print(" Waiting for server configuration...")
        while samplerate is None and not stop_flag:
            time.sleep(0.01)

        if stop_flag:
            print(" Failed to get samplerate from server")
            return

        print(f" Starting playback at {samplerate} Hz (WebSocket processed)")

        # Start playback worker
        play_thread = threading.Thread(target=playback_worker, daemon=True)
        play_thread.start()

        # Wait for WebSocket thread to finish
        websocket_thread.join()
        
        # Wait for audio queue to empty
        print(" Waiting for audio playback to finish...")
        while not audio_queue.empty():
            time.sleep(0.1)
        
        stop_flag = True
        play_thread.join(timeout=2.0)
        
        print(" Streaming finished.")
        
    except KeyboardInterrupt:
        print(" Interrupted by user")
        stop_flag = True
    except Exception as e:
        print(f" Main error: {e}")

if __name__ == "__main__":
    main()
